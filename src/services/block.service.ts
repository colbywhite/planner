import {createSupabaseClient} from "./supabase.service";
import type {Database} from "./database.types";
import type {AstroCookies} from "astro";

type AutoGeneratedPropNames = 'id' | 'owner' | 'created_at';
export type BlockInsert = Exclude<Database.public.Tables.blocks.Insert, AutoGeneratedPropNames>
export type BlockWithTasks = Database.public.Tables.blocks.Row & { tasks: Database.public.Tables.tasks.Row[] }
export type TaskInsert = Exclude<Database.public.Tables.tasks.Insert, AutoGeneratedPropNames>

export class BlockService {
    private client: ReturnType<typeof createSupabaseClient>

    public constructor(cookies: AstroCookies) {
        this.client = createSupabaseClient(cookies)
    }

    public async countBlocks() {
        const {count, error} = await this.client.from('blocks')
            .select('*', {count: 'exact', head: true})
        if (error) {
            console.error('countBlocks', error.message)
            throw error
        }
        return count
    }

    public async getBlock(id: string) {
        const {data, error} = await this.client.from('blocks')
            .select()
            .eq('id', id)
        if (data === null || error) {
            console.error('no block found for', id)
            throw error
        }
        return data
    }

    /**
     * in a list of blocks ordered by start date, return this blocks 0-based index
     */
    public async getBlockIndex(id: string) {
        const {data, error} = await this.client.from('blocks')
            .select<Database.public.Tables.blocks.Row>()
            .order('start', {ascending: true})
            .limit(100) // TODO do this query via a view so we don't have to worry about this
        if (error) {
            console.error('getBlockIndex', error)
            throw error
        }
        return data.findIndex(block => block.id === id)
    }

    public async getBlockAndTasks(index: number) {
        const count = await this.countBlocks();
        if (count <= 0) {
            return {block: null, index: 0, previousIndex: 0, nextIndex: 0}
        }
        const lastBlockIndex = count - 1;
        const safeIndex = Math.max(0, Math.min(index, lastBlockIndex))
        const previousIndex = safeIndex - 1 >= 0 ? safeIndex - 1 : undefined
        const nextIndex = safeIndex + 1 <= lastBlockIndex ? safeIndex + 1 : undefined

        const {data, error} = await this.client.from('blocks')
            .select('*, tasks(*)')
            .order('start', {ascending: true})
            .range(safeIndex, safeIndex + 1)
            .limit(1)
            .single<BlockWithTasks>()
        if (error) {
            console.error('getBlockAndTasks', error)
            throw error
        }
        return {block: data, index: safeIndex, previousIndex, nextIndex}
    }

    public async createBlock(block: BlockInsert) {
        const user = await this.getUser()
        console.log('createBlock', {...block, owner: user.id})
        const {data, error} = await this.client.from('blocks')
            .insert({...block, owner: user.id})
            .select()
            .single()
        if (error) {
            console.error('createBlock', error)
            throw error
        }
        return data
    }

    public async createTask(task: TaskInsert) {
        const user = await this.getUser()
        console.log('createTask', {...task, owner: user.id})
        // confirm block exists before inserting
        await this.getBlock(task.block_id)
        const {data, error} = await this.client.from('tasks')
            .insert({...task, owner: user.id})
            .select()
            .single()
        if (error) {
            console.error('createTask', error)
            throw error
        }
        console.log('createTask', {data})
        return data
    }

    private async getUser() {
        const {data: {user}, error} = await this.client.auth.getUser()
        if (user === null) {
            throw error
        }
        return user
    }
}
