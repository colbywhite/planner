import {createSupabaseClient} from "./supabase.service";
import type {Database} from "./database.types";
import type {AstroCookies} from "astro";
import type {SupabaseClient} from "@supabase/supabase-js";

type AutoGeneratedPropNames = 'id' | 'owner' | 'created_at';
type BlockTypes = Database['public']['Views']['numbered_blocks']
type Block = BlockTypes['Row']
export type BlockInsert = Omit<BlockTypes['Insert'], AutoGeneratedPropNames>
type TaskTypes = Database['public']['Tables']['tasks']
type Task = TaskTypes['Row']
export type BlockWithTasks = Block & { tasks: Task[] }
export type TaskInsert = Omit<TaskTypes['Insert'], AutoGeneratedPropNames>

export class BlockService {
    private client: SupabaseClient<Database>

    public constructor(cookies: AstroCookies) {
        this.client = createSupabaseClient(cookies)
    }

    public async countBlocks() {
        const {count, error} = await this.client.from('blocks')
            .select('*', {count: 'exact', head: true})
        if (error || count === null) {
            console.error('countBlocks', error?.message)
            throw error
        }
        return count
    }

    public async getBlock(id: string) {
        const {data, error} = await this.client.from('blocks')
            .select()
            .eq('id', id)
        if (data === null || error) {
            console.error('no block found for', id)
            throw error
        }
        return data
    }

    /**
     * in a list of blocks ordered by start date, return this blocks 0-based index
     */
    public async getBlockIndex(id: string) {
        const {data, error} = await this.client.from('blocks')
            .select()
            .order('start', {ascending: true})
            .limit(100) // TODO do this query via a view so we don't have to worry about this
        if (error) {
            console.error('getBlockIndex', error)
            throw error
        }
        return data.findIndex(block => block.id === id)
    }

    /**
     * TODO: the bulk of this logic could be done in a PG function to make this less bug prone
     *   - truncate the requested index into the proper range (i.e. get the first if too small; get the last if too big)
     *   - safely handle case where there are no rows
     *   - return the appropriate paging index values automatically
     */
    public async getBlockAndTasks(index: number) {
        const safeIndex = Math.max(1, index)

        let block;
        const {data: specific_block, error} = await this.client.from('numbered_blocks')
            .select('*, tasks(*)')
            // .or(`index.eq.${safeIndex},total.lte.${safeIndex}`)
            .eq('index', safeIndex)
            .maybeSingle<BlockWithTasks>()
        if (error) {
            console.error('getBlockAndTasks', error)
            throw error
        }
        if(specific_block===null) {
            // this means the specific index is greater than the total that are present.
            // return the last block in that scenario
            const {data: last_block} = await this.client.from('numbered_blocks')
                .select('*, tasks(*)')
                .order('index', {ascending: false})
                .limit(1)
                .maybeSingle()
            block = last_block
        } else {
            block = specific_block
        }
        const previousIndex = block.index - 1 > 0 ? block.index - 1 : undefined
        const nextIndex = block.index + 1 <= block.total ? block.index + 1 : undefined
        return {block, index: block.index, previousIndex, nextIndex}
    }

    public async createBlock(block: BlockInsert) {
        const user = await this.getUser()
        console.log('createBlock', {...block, owner: user.id})
        const {data, error} = await this.client.from('blocks')
            .insert({...block, owner: user.id})
            .select()
            .single()
        if (error) {
            console.error('createBlock', error)
            throw error
        }
        return data
    }

    public async createTask(task: TaskInsert) {
        const user = await this.getUser()
        console.log('createTask', {...task, owner: user.id})
        // confirm block exists before inserting
        await this.getBlock(task.block_id)
        const {data, error} = await this.client.from('tasks')
            .insert({...task, owner: user.id})
            .select()
            .single()
        if (error) {
            console.error('createTask', error)
            throw error
        }
        return data
    }

    private async getUser() {
        const {data: {user}, error} = await this.client.auth.getUser()
        if (user === null) {
            throw error
        }
        return user
    }
}
